/root/quantum-secure-commerce/services/__init__.py
# services/__init__.py
"""Services module exports"""
from .auth_service import auth_service
from .payment_service import SecurePaymentProcessor
from .session_service import session_service
from .rate_limiter import rate_limiter

__all__ = [
    'auth_service',
    'SecurePaymentProcessor',
    'session_service',
    'rate_limiter'
]
/root/quantum-secure-commerce/services/auth_service.py
import bcrypt
import jwt
from datetime import datetime, timedelta
from typing import Dict, Any, Optional
from fastapi import HTTPException, status
import logging
import re

logger = logging.getLogger(__name__)

class AuthService:
    """Enhanced authentication with security features"""
    
    def __init__(self):
        try:
            from config.dev_config import SecurityConfig
            self.jwt_secret = SecurityConfig.get_jwt_secret()
            self.jwt_algorithm = SecurityConfig.JWT_ALGORITHM
            self.jwt_expiration_hours = SecurityConfig.JWT_EXPIRATION_HOURS
        except Exception as e:
            logger.warning(f"Using fallback JWT config: {e}")
            self.jwt_secret = "fallback_secret_key_for_development"
            self.jwt_algorithm = "HS256"
            self.jwt_expiration_hours = 24
    
    def hash_password(self, password: str) -> str:
        """Hash password using bcrypt"""
        try:
            salt = bcrypt.gensalt()
            hashed = bcrypt.hashpw(password.encode('utf-8'), salt)
            return hashed.decode('utf-8')
        except Exception as e:
            logger.error(f"Password hashing error: {e}")
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="Password processing failed"
            )
    
    def verify_password(self, password: str, hashed_password: str) -> bool:
        """Verify password against hash"""
        try:
            return bcrypt.checkpw(password.encode('utf-8'), hashed_password.encode('utf-8'))
        except Exception as e:
            logger.error(f"Password verification error: {e}")
            return False
    
    def validate_password_strength(self, password: str) -> bool:
        """Validate password strength"""
        if len(password) < 8:
            return False
        
        # Check for at least one uppercase, lowercase, digit, and special character
        if not re.search(r"[A-Z]", password):
            return False
        if not re.search(r"[a-z]", password):
            return False
        if not re.search(r"\d", password):
            return False
        if not re.search(r"[!@#$%^&*(),.?\":{}|<>]", password):
            return False
        
        return True
    
    def create_access_token(self, data: Dict[str, Any]) -> str:
        """Create JWT access token"""
        try:
            to_encode = data.copy()
            expire = datetime.utcnow() + timedelta(hours=self.jwt_expiration_hours)
            to_encode.update({"exp": expire})
            
            encoded_jwt = jwt.encode(to_encode, self.jwt_secret, algorithm=self.jwt_algorithm)
            return encoded_jwt
        except Exception as e:
            logger.error(f"Token creation error: {e}")
            # Fallback to simple token for development
            return f"dev_token_{data.get('id', 'unknown')}"
    
    def verify_token(self, authorization_header: str) -> Dict[str, Any]:
        """Verify JWT token from Authorization header"""
        try:
            if not authorization_header.startswith("Bearer "):
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="Invalid authorization header format"
                )
            
            token = authorization_header.replace("Bearer ", "")
            
            # Handle development tokens
            if token.startswith("dev_token_") or token == "demo_token_123":
                return {
                    "user_id": "demo_user_123",
                    "id": "demo_user_123", 
                    "email": "test@example.com",
                    "username": "testuser",
                    "is_admin": False
                }
            
            # Real JWT verification
            payload = jwt.decode(token, self.jwt_secret, algorithms=[self.jwt_algorithm])
            
            # Check if token is expired
            if datetime.utcnow() > datetime.fromtimestamp(payload.get("exp", 0)):
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="Token has expired"
                )
            
            return payload
            
        except jwt.ExpiredSignatureError:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Token has expired"
            )
        except jwt.JWTError as e:
            logger.error(f"JWT verification error: {e}")
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid token"
            )
        except Exception as e:
            logger.error(f"Token verification error: {e}")
            # For development, allow mock tokens
            token = authorization_header.replace("Bearer ", "")
            if token == "demo_token_123":
                return {
                    "user_id": "demo_user_123",
                    "id": "demo_user_123",
                    "email": "test@example.com", 
                    "username": "testuser",
                    "is_admin": False
                }
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Authentication failed"
            )

# Global instance
auth_service = AuthService()
/root/quantum-secure-commerce/services/payment_service.py
"""Mock Payment Service for Testing"""
from enum import Enum
from dataclasses import dataclass
from decimal import Decimal
from typing import Optional, Dict, Any, List
import uuid
import asyncio
from datetime import datetime

class PaymentStatus(Enum):
    PENDING = "pending"
    PROCESSING = "processing" 
    COMPLETED = "completed"
    FAILED = "failed"
    REFUNDED = "refunded"

class PaymentMethod(Enum):
    CREDIT_CARD = "credit_card"
    DEBIT_CARD = "debit_card"
    CRYPTOCURRENCY = "cryptocurrency"
    BANK_TRANSFER = "bank_transfer"

@dataclass
class PaymentRequest:
    customer_id: str
    merchant_id: str
    amount: Decimal
    currency: str
    payment_method: PaymentMethod
    card_data: Optional[Dict[str, str]] = None
    billing_address: Optional[Dict[str, str]] = None
    items: Optional[List[Dict[str, Any]]] = None
    metadata: Optional[Dict[str, Any]] = None

@dataclass  
class PaymentResponse:
    payment_id: str
    status: PaymentStatus
    transaction_id: Optional[str] = None
    signature: Optional[str] = None
    encrypted_receipt: Optional[Dict[str, Any]] = None
    timestamp: Optional[str] = None
    message: Optional[str] = None

class SecurePaymentProcessor:
    """Mock payment processor for testing"""
    
    def __init__(self):
        print("Initializing SecurePaymentProcessor (Mock Version)")
        
    async def process_payment(self, request: PaymentRequest) -> PaymentResponse:
        """Process a payment request"""
        # Simulate processing delay
        await asyncio.sleep(0.1)
        
        # Generate mock response
        payment_id = str(uuid.uuid4())
        transaction_id = f"TXN-{uuid.uuid4().hex[:12].upper()}"
        
        return PaymentResponse(
            payment_id=payment_id,
            status=PaymentStatus.COMPLETED,
            transaction_id=transaction_id,
            signature="MOCK_SIGNATURE_BASE64_ENCODED",
            encrypted_receipt={
                "encrypted": True,
                "data": "mock_encrypted_receipt_data"
            },
            timestamp=datetime.utcnow().isoformat(),
            message="Payment processed successfully (mock)"
        )
    
    async def refund_payment(self, transaction_id: str, amount: Optional[Decimal] = None, reason: Optional[str] = None) -> PaymentResponse:
        """Process a refund"""
        await asyncio.sleep(0.1)
        
        return PaymentResponse(
            payment_id=str(uuid.uuid4()),
            status=PaymentStatus.REFUNDED,
            transaction_id=transaction_id,
            timestamp=datetime.utcnow().isoformat(),
            message=f"Refund processed: {reason or 'Customer request'}"
        )
    
    async def verify_payment(self, transaction_id: str) -> Dict[str, Any]:
        """Verify a payment"""
        return {
            "transaction_id": transaction_id,
            "verified": True,
            "status": PaymentStatus.COMPLETED.value,
            "verified_at": datetime.utcnow().isoformat()
        }

/root/quantum-secure-commerce/services/rate_limiter.py

"""
Rate limiting service using Redis
"""
import redis
from datetime import datetime, timedelta
from typing import Tuple
from config.dev_config import SecurityConfig
import logging
from typing import Dict, List, Optional, Any

logger = logging.getLogger(__name__)

class RateLimiter:
    """Rate limiting implementation"""
    
    def __init__(self):
        try:
            # Thử kết nối Redis với cấu hình đơn giản hơn cho testing
            self.redis_client = redis.from_url(
                SecurityConfig.get_redis_url(),
                decode_responses=True,
                socket_connect_timeout=5,
                socket_timeout=5,
                retry_on_timeout=True
            )
            # Test connection
            self.redis_client.ping()
            self.redis_available = True
        except Exception as e:
            logger.warning(f"Redis không khả dụng, sử dụng in-memory storage: {e}")
            self.redis_available = False
            self._memory_store = {}  # Fallback to memory
        
        # Rate limit configurations
        self.limits = {
            'login': {'requests': 5, 'window': 300},  # 5 attempts per 5 minutes
            'api': {'requests': 100, 'window': 60},   # 100 requests per minute
            'payment': {'requests': 10, 'window': 600}, # 10 payments per 10 minutes
            'register': {'requests': 3, 'window': 3600}, # 3 registrations per hour
        }
    
    def check_rate_limit(self, key: str, limit_type: str = 'api') -> Tuple[bool, int]:
        """
        Check if rate limit is exceeded
        Returns: (is_allowed, remaining_requests)
        """
        if limit_type not in self.limits:
            limit_type = 'api'
        
        limit_config = self.limits[limit_type]
        max_requests = limit_config['requests']
        window = limit_config['window']
        
        # Create Redis key
        redis_key = f"rate_limit:{limit_type}:{key}"
        
        try:
            if self.redis_available:
                return self._check_redis_rate_limit(redis_key, max_requests, window)
            else:
                return self._check_memory_rate_limit(redis_key, max_requests, window)
                
        except Exception as e:
            logger.error(f"Rate limiter error: {e}")
            # On error, allow request but log
            return True, 0
    
    def _check_redis_rate_limit(self, redis_key: str, max_requests: int, window: int) -> Tuple[bool, int]:
        """Check rate limit using Redis"""
        # Get current count
        current = self.redis_client.get(redis_key)
        
        if current is None:
            # First request
            self.redis_client.setex(redis_key, window, 1)
            return True, max_requests - 1
        
        current_count = int(current)
        
        if current_count >= max_requests:
            # Rate limit exceeded
            ttl = self.redis_client.ttl(redis_key)
            logger.warning(f"Rate limit exceeded for key {redis_key}")
            return False, 0
        
        # Increment counter
        new_count = self.redis_client.incr(redis_key)
        
        return True, max_requests - new_count
    
    def _check_memory_rate_limit(self, key: str, max_requests: int, window: int) -> Tuple[bool, int]:
        """Fallback rate limiting using memory"""
        import time
        current_time = time.time()
        
        if key not in self._memory_store:
            self._memory_store[key] = {'count': 1, 'reset_time': current_time + window}
            return True, max_requests - 1
        
        store_data = self._memory_store[key]
        
        # Check if window has expired
        if current_time > store_data['reset_time']:
            self._memory_store[key] = {'count': 1, 'reset_time': current_time + window}
            return True, max_requests - 1
        
        # Check if limit exceeded
        if store_data['count'] >= max_requests:
            return False, 0
        
        # Increment counter
        store_data['count'] += 1
        remaining = max_requests - store_data['count']
        
        return True, remaining
    
    def get_limit_info(self, key: str, limit_type: str = 'api') -> Dict:
        """Get rate limit information"""
        redis_key = f"rate_limit:{limit_type}:{key}"
        limit_config = self.limits.get(limit_type, self.limits['api'])
        
        if self.redis_available:
            try:
                current = self.redis_client.get(redis_key)
                ttl = self.redis_client.ttl(redis_key) if current else 0
            except:
                current = None
                ttl = 0
        else:
            current = self._memory_store.get(redis_key, {}).get('count', 0)
            ttl = 0
        
        return {
            'limit': limit_config['requests'],
            'window': limit_config['window'],
            'used': int(current) if current else 0,
            'remaining': limit_config['requests'] - (int(current) if current else 0),
            'reset_in': ttl if ttl > 0 else 0
        }
    
    def reset_limit(self, key: str, limit_type: str = 'api'):
        """Reset rate limit for a key"""
        redis_key = f"rate_limit:{limit_type}:{key}"
        
        if self.redis_available:
            try:
                self.redis_client.delete(redis_key)
            except:
                pass
        else:
            self._memory_store.pop(redis_key, None)

# Initialize global rate limiter
rate_limiter = RateLimiter()
/root/quantum-secure-commerce/services/secret_manager.py
"""
Real Secret Manager - KHÔNG LƯU SECRETS TRONG CODE
"""
import os
import json
import base64
import logging
from typing import Optional, Dict
from pathlib import Path
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC

logger = logging.getLogger(__name__)

class SecretManager:
    """
    Real Secret Manager - Chỉ lưu secrets trong:
    1. Environment variables (cho development)
    2. Encrypted files với master key từ ENV
    3. External secret stores (Vault, AWS Secrets Manager)
    
    KHÔNG BAO GIỜ commit secrets vào git!
    """
    
    def __init__(self):
        self.secrets_file = Path("secrets/encrypted_secrets.json")
        self.master_key = self._get_master_key()
        self.fernet = Fernet(self.master_key) if self.master_key else None
        
        # Tạo thư mục secrets nếu chưa có
        self.secrets_file.parent.mkdir(exist_ok=True)
        
        # Bảo vệ thư mục secrets
        os.chmod(self.secrets_file.parent, 0o700)
        
    def _get_master_key(self) -> Optional[bytes]:
        """Lấy master key từ ENV hoặc tạo mới"""
        # 1. Thử lấy từ environment variable
        env_key = os.getenv('MASTER_ENCRYPTION_KEY')
        if env_key:
            try:
                return base64.b64decode(env_key)
            except:
                logger.error("Invalid MASTER_ENCRYPTION_KEY in environment")
        
        # 2. Thử lấy từ file key
        key_file = Path("secrets/.master.key")
        if key_file.exists():
            try:
                with open(key_file, 'rb') as f:
                    return f.read()
            except Exception as e:
                logger.error(f"Cannot read master key file: {e}")
        
        # 3. Tạo master key mới từ password
        master_password = os.getenv('MASTER_PASSWORD')
        if not master_password:
            logger.warning("No MASTER_PASSWORD set! Using default (INSECURE)")
            master_password = "quantum_secure_default_change_me"
        
        # Derive key từ password
        salt = b'quantum_secure_salt_2025'  # In production, use random salt
        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=32,
            salt=salt,
            iterations=100000,
        )
        key = base64.urlsafe_b64encode(kdf.derive(master_password.encode()))
        
        # Lưu key file để lần sau không phải tạo lại
        try:
            with open(key_file, 'wb') as f:
                f.write(key)
            os.chmod(key_file, 0o600)  # Chỉ owner đọc được
            logger.info("✅ Master key created and saved")
        except Exception as e:
            logger.error(f"Cannot save master key: {e}")
        
        return key
    
    def store_secret(self, key: str, value: str) -> bool:
        """Lưu secret được mã hóa"""
        if not self.fernet:
            logger.error("No encryption key available")
            return False
            
        try:
            # Đọc secrets hiện tại
            secrets = {}
            if self.secrets_file.exists():
                with open(self.secrets_file, 'r') as f:
                    secrets = json.load(f)
            
            # Mã hóa secret
            encrypted_value = self.fernet.encrypt(value.encode()).decode()
            secrets[key] = encrypted_value
            
            # Lưu lại file
            with open(self.secrets_file, 'w') as f:
                json.dump(secrets, f)
            os.chmod(self.secrets_file, 0o600)
            
            logger.info(f"✅ Secret '{key}' stored securely")
            return True
            
        except Exception as e:
            logger.error(f"Failed to store secret '{key}': {e}")
            return False
    
    def get_secret(self, key: str) -> Optional[str]:
        """Lấy secret và giải mã"""
        # 1. Thử lấy từ environment trước
        env_value = os.getenv(key.upper())
        if env_value:
            return env_value
            
        # 2. Thử lấy từ file mã hóa
        if not self.fernet:
            logger.error("No encryption key available")
            return None
            
        try:
            if not self.secrets_file.exists():
                return None
                
            with open(self.secrets_file, 'r') as f:
                secrets = json.load(f)
            
            if key not in secrets:
                return None
            
            # Giải mã
            encrypted_value = secrets[key].encode()
            decrypted_value = self.fernet.decrypt(encrypted_value).decode()
            
            return decrypted_value
            
        except Exception as e:
            logger.error(f"Failed to get secret '{key}': {e}")
            return None
    
    def initialize_default_secrets(self):
        """Khởi tạo secrets mặc định nếu chưa có"""
        default_secrets = {
            'jwt_secret': base64.b64encode(os.urandom(32)).decode(),
            'database_password': os.getenv('DB_PASSWORD', 'quantum_pass'),
            'dilithium_master_key': base64.b64encode(os.urandom(64)).decode(),
            'ibe_master_key': base64.b64encode(os.urandom(32)).decode(),
            'redis_password': os.getenv('REDIS_PASSWORD', 'redis_pass'),
        }
        
        for key, value in default_secrets.items():
            if not self.get_secret(key):
                self.store_secret(key, value)
                logger.info(f"✅ Initialized secret: {key}")
    
    def list_secret_keys(self) -> list:
        """List tất cả secret keys (không show values)"""
        try:
            if not self.secrets_file.exists():
                return []
                
            with open(self.secrets_file, 'r') as f:
                secrets = json.load(f)
            
            return list(secrets.keys())
            
        except Exception as e:
            logger.error(f"Failed to list secrets: {e}")
            return []
    
    def delete_secret(self, key: str) -> bool:
        """Xóa secret"""
        try:
            if not self.secrets_file.exists():
                return False
                
            with open(self.secrets_file, 'r') as f:
                secrets = json.load(f)
            
            if key in secrets:
                del secrets[key]
                
                with open(self.secrets_file, 'w') as f:
                    json.dump(secrets, f)
                
                logger.info(f"✅ Secret '{key}' deleted")
                return True
            
            return False
            
        except Exception as e:
            logger.error(f"Failed to delete secret '{key}': {e}")
            return False

# Global instance
secret_manager = SecretManager()

# Khởi tạo secrets khi import module
try:
    secret_manager.initialize_default_secrets()
except Exception as e:
    logger.error(f"Failed to initialize secrets: {e}")
/root/quantum-secure-commerce/services/session_service.py
# services/session_service.py
"""
Secure session management using Redis
"""
import redis
import json
import secrets
from datetime import datetime, timedelta
from typing import Optional, Dict, Any
from config.dev_config import SecurityConfig
import logging

logger = logging.getLogger(__name__)

class SessionService:
    """Secure session management with Redis"""
    
    # Thêm vào đầu class SessionService:
def __init__(self):
    try:
        # Redis connection
        self.redis_client = redis.from_url(
            SecurityConfig.REDIS_URL,
            decode_responses=True,
            socket_connect_timeout=5,
            socket_timeout=5
        )
        self.redis_client.ping()
        self.redis_available = True
        logger.info("✅ Redis session storage connected")
    except Exception as e:
        logger.warning(f"⚠️ Redis unavailable for sessions: {e}")
        self.redis_available = False
        self._memory_sessions = {}  # Fallback
    
    # Session configuration
    self.session_prefix = "session:"
    self.session_timeout = SecurityConfig.SESSION_TIMEOUT_MINUTES * 60
        
    def create_session(self, user_id: int, user_data: Dict[str, Any]) -> str:
        """Create a new session"""
        # Generate secure session ID
        session_id = secrets.token_urlsafe(32)
        
        # Session data
        session_data = {
            'user_id': user_id,
            'email': user_data.get('email'),
            'username': user_data.get('username'),
            'is_admin': user_data.get('is_admin', False),
            'created_at': datetime.utcnow().isoformat(),
            'last_activity': datetime.utcnow().isoformat(),
            'ip_address': user_data.get('ip_address'),
            'user_agent': user_data.get('user_agent'),
        }
        
        # Store in Redis with expiration
        key = f"{self.session_prefix}{session_id}"
        self.redis_client.setex(
            key,
            self.session_timeout,
            json.dumps(session_data)
        )
        
        logger.info(f"Created session for user {user_id}")
        
        return session_id
    
    def get_session(self, session_id: str) -> Optional[Dict[str, Any]]:
        """Get session data"""
        key = f"{self.session_prefix}{session_id}"
        
        # Get from Redis
        data = self.redis_client.get(key)
        if not data:
            return None
        
        try:
            session_data = json.loads(data)
            
            # Update last activity
            session_data['last_activity'] = datetime.utcnow().isoformat()
            
            # Extend expiration
            self.redis_client.setex(
                key,
                self.session_timeout,
                json.dumps(session_data)
            )
            
            return session_data
            
        except Exception as e:
            logger.error(f"Failed to get session: {e}")
            return None
    
    def destroy_session(self, session_id: str) -> bool:
        """Destroy a session"""
        key = f"{self.session_prefix}{session_id}"
        result = self.redis_client.delete(key)
        
        logger.info(f"Destroyed session {session_id}")
        
        return result > 0
    
    def destroy_all_user_sessions(self, user_id: int) -> int:
        """Destroy all sessions for a user"""
        count = 0
        
        # Scan for all sessions
        for key in self.redis_client.scan_iter(f"{self.session_prefix}*"):
            data = self.redis_client.get(key)
            if data:
                try:
                    session_data = json.loads(data)
                    if session_data.get('user_id') == user_id:
                        self.redis_client.delete(key)
                        count += 1
                except:
                    pass
        
        logger.info(f"Destroyed {count} sessions for user {user_id}")
        
        return count
    
    def update_session_activity(self, session_id: str) -> bool:
        """Update session last activity"""
        key = f"{self.session_prefix}{session_id}"
        
        data = self.redis_client.get(key)
        if not data:
            return False
        
        try:
            session_data = json.loads(data)
            session_data['last_activity'] = datetime.utcnow().isoformat()
            
            # Reset expiration
            self.redis_client.setex(
                key,
                self.session_timeout,
                json.dumps(session_data)
            )
            
            return True
            
        except Exception as e:
            logger.error(f"Failed to update session: {e}")
            return False
    
    def get_active_sessions_count(self) -> int:
        """Get count of active sessions"""
        count = 0
        for _ in self.redis_client.scan_iter(f"{self.session_prefix}*"):
            count += 1
        return count
    
    def cleanup_expired_sessions(self):
        """Clean up expired sessions (Redis handles this automatically)"""
        # Redis automatically removes expired keys
        # This method is here for completeness
        pass

# Initialize global session service
session_service = SessionService()

/root/quantum-secure-commerce/.env
# =================================
# QUANTUM COMMERCE - DEVELOPMENT
# =================================

# Application Config
APP_NAME=quantum-commerce
APP_ENV=development
DEBUG=true

# Secret Management
USE_ENCRYPTED_SECRETS=false
USE_REAL_CRYPTO=false

# Database Config - ALL VARIATIONS TO COVER ALL CODE PATHS
DB_HOST=localhost
DB_PORT=5432
DB_NAME=quantum_commerce

# Primary database user (docker container)
DB_USER=quantum_user
DB_PASSWORD=quantum_secure_pass_123

# Legacy database user (code might reference this)
DATABASE_USER=quantum_user
DATABASE_PASSWORD=quantum_secure_pass_123

# Old naming convention (some modules might use)
QSC_USER=quantum_user
QSC_PASSWORD=quantum_secure_pass_123

# Postgres user variations
POSTGRES_USER=quantum_user
POSTGRES_PASSWORD=quantum_secure_pass_123
POSTGRES_DB=quantum_commerce

# Redis Config - ALL VARIATIONS
REDIS_HOST=localhost
REDIS_PORT=6379
REDIS_PASSWORD=redis_secure_pass_456
REDIS_AUTH=redis_secure_pass_456

# Vault Config
VAULT_ADDR=http://localhost:8200
VAULT_TOKEN=dev_vault_token_789

# Development master password
MASTER_PASSWORD=dev_test_123

# Security Features
RATE_LIMIT_ENABLED=true
SESSION_TIMEOUT_MINUTES=30
JWT_SECRET_KEY=dev_jwt_secret_for_testing_only

# Monitoring
PROMETHEUS_HOST=localhost
PROMETHEUS_PORT=9090
GRAFANA_HOST=localhost
GRAFANA_PORT=3030
GRAFANA_PASSWORD=quantum_admin_123

# Feature Flags
ENABLE_METRICS=true
ENABLE_MONITORING=true
ENABLE_RATE_LIMITING=true

# Crypto Config
CRYPTO_MODE=mock
QUANTUM_SECURE=false

# Database Engine Override
DATABASE_URL=postgresql://quantum_user:quantum_secure_pass_123@localhost:5432/quantum_commerce
SQLALCHEMY_DATABASE_URL=postgresql://quantum_user:quantum_secure_pass_123@localhost:5432/quantum_commerce

Mình làm đúng không? Có cần chỉnh sửa gì không?
# =================================
/root/quantum-secure-commerce/.env.example
APP_NAME=quantum-commerce
APP_ENV=development/production
DEBUG=true

DB_HOST=localhost
DB_PORT=5432
DB_USER=quantum_user
DB_PASSWORD=quantum_secure_pass_123
DB_NAME=quantum_commerce

REDIS_HOST=localhost
REDIS_PORT=6379
REDIS_PASSWORD=redis_secure_pass_456

VAULT_ADDR=http://localhost:8200
VAULT_TOKEN=dev_vault_token_789

USE_REAL_CRYPTO=true
MASTER_PASSWORD=test_master_key_123

RATE_LIMIT_ENABLED=true
SESSION_TIMEOUT_MINUTES=30

PROMETHEUS_HOST=localhost
PROMETHEUS_PORT=9090
GRAFANA_HOST=localhost  
GRAFANA_PORT=3030
GRAFANA_PASSWORD=quantum_admin_123
/root/quantum-secure-commerce/.env.local 
export JWT_SECRET_KEY='kalXnpycRfujiIC1WWUbfoxGkfoYnLcaPEytJ0Eo2Rg='
export DILITHIUM_MASTER_KEY='e5vlABz+e+wGFQjib58JmrDo+lJ+ACj4IUQ8sOIOnNrCgSWXG+WUFoRWBNNTmx1o
rLlIZgG3uPHKVTt06YYD2w=='
export IBE_MASTER_KEY='qMCDLwHo1mH1F35pXep3z8Q/X7nISN7p6MBaUmSWRsU='
export DB_PASSWORD='2ES1D+vNTW7uBHg4CBua9ivEsHT3GHgL'
export REDIS_PASSWORD='48Yt+NGJ6kd617CTivjov3Z7e0SjVE7x'

/root/quantum-secure-commerce/.env.prod 
USE_REAL_CRYPTO=true

# Vault configuration
VAULT_ADDR=http://vault:8200
VAULT_TOKEN=your-vault-token-here
/root/quantum-secure-commerce/.env.production 
# .env.production
# PRODUCTION ENVIRONMENT - NO SECRETS HERE!
# All secrets are stored encrypted in secrets/ directory

# Application Config
APP_NAME=quantum-commerce
APP_ENV=production
DEBUG=false

# Database Connection (passwords stored encrypted)
DB_HOST=postgres
DB_PORT=5432
DB_NAME=quantum_commerce
DB_USER=qsc_user

# Redis Connection  
REDIS_HOST=redis
REDIS_PORT=6379

# Vault Config
VAULT_ADDR=http://vault:8200

# Feature Flags
USE_REAL_CRYPTO=true
RATE_LIMIT_ENABLED=true
SESSION_TIMEOUT_MINUTES=30

# Monitoring
PROMETHEUS_PORT=9090
GRAFANA_PORT=3030

# ⚠️ SECRETS ĐƯỢC LẤY TỪ ENCRYPTED STORAGE
# KHÔNG BAO GIỜ commit passwords vào đây!

/root/quantum-secure-commerce/.gitignore
# SECURITY - NEVER COMMIT THESE!
secrets/
.env*
*.key
*.pem
master_password.txt
vault_token.txt
env.txt

# Crypto keys
keys/dilithium/*.key
keys/ibe/*.key
keys/*.pem

# Logs có thể chứa sensitive data
logs/*.log
logs/security.log

# Database
*.sql
*.db
data/

# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
env/
venv/
ENV/

# Docker
.dockerignore

# Backup files
*.backup
*.bak
temp/

# IDE
.vscode/
.idea/
*.swp
*.swo

# OS
.DS_Store
Thumbs.db

# Monitoring data
prometheus_data/
grafana_data/

# SECURITY - NEVER COMMIT THESE!
secrets/
.env
.env.local
.env.production
.env.development
*.key
*.pem
master_password.txt
vault_token.txt

# Crypto keys
keys/dilithium/
keys/ibe/
keys/*.key

# Logs có thể chứa sensitive data
logs/*.log
logs/security.log

# Database dumps
*.sql
*.db

# Backup files
*.backup
*.bak
temp/

# SECURITY - NEVER COMMIT THESE!
secrets/
.env
.env.local
.env.production
.env.development
*.key
*.pem
master_password.txt
vault_token.txt

# Crypto keys
keys/dilithium/
keys/ibe/
keys/*.key

# Logs có thể chứa sensitive data
logs/*.log
logs/security.log

# Database dumps
*.sql
*.db

# Backup files
*.backup
*.bak
temp/

#Setup Secrets 
scripts/setup_prodution_secrets.py
scripts/setup_prodution_secrets.py


# SECURITY - NEVER COMMIT THESE!
secrets/
.env
.env.local
.env.production
.env.development
*.key
*.pem
master_password.txt
vault_token.txt

# Crypto keys
keys/dilithium/
keys/ibe/
keys/*.key

# Logs có thể chứa sensitive data
logs/*.log
logs/security.log

# Database dumps
*.sql
*.db

# Backup files
*.backup
*.bak
temp/

# SECURITY - NEVER COMMIT THESE!
secrets/
.env
.env.local
.env.production
.env.development
*.key
*.pem
master_password.txt
vault_token.txt

# Crypto keys
keys/dilithium/
keys/ibe/
keys/*.key

# Logs có thể chứa sensitive data
logs/*.log
logs/security.log

# Database dumps
*.sql
*.db

# Backup files
*.backup
*.bak
temp/

# SECRETS - KHÔNG BAO GIỜ COMMIT!
secrets/
.env
.env.local
.env.production
*.key
*.pem

# Crypto keys
keys/dilithium/
keys/ibe/
dilithium_*.key
ibe_*.key

# Database
*.db
*.sqlite

# Logs có thể chứa sensitive data
logs/
*.log

# Docker secrets
docker-compose.override.yml
.docker/

# Backup files
*.bak
*.backup

# SECRETS - KHÔNG BAO GIỜ COMMIT!
secrets/
.env
.env.local
.env.production
*.key
*.pem

# Crypto keys
keys/dilithium/
keys/ibe/
dilithium_*.key
ibe_*.key

# Database
*.db
*.sqlite

# Logs có thể chứa sensitive data
logs/
*.log

# Docker secrets
docker-compose.override.yml
.docker/

# Backup files
*.bak
*.backup

# SECRETS - KHÔNG BAO GIỜ COMMIT!
secrets/
.env
.env.local
.env.production
*.key
*.pem

# Crypto keys
keys/dilithium/
keys/ibe/
dilithium_*.key
ibe_*.key

# Database
*.db
*.sqlite

# Logs có thể chứa sensitive data
logs/
*.log

# Docker secrets
docker-compose.override.yml
.docker/

# Backup files
*.bak
*.backup

# SECRETS - KHÔNG BAO GIỜ COMMIT!
secrets/
.env
.env.local
.env.production
*.key
*.pem

# Crypto keys
keys/dilithium/
keys/ibe/
dilithium_*.key
ibe_*.key

# Database
*.db
*.sqlite

# Logs có thể chứa sensitive data
logs/
*.log

# Docker secrets
docker-compose.override.yml
.docker/

# Backup files
*.bak
*.backup

/root/quantum-secure-commerce/docker-compose-simple.yml
version: '3.8'

services:
  postgres:
    image: postgres:15-alpine
    container_name: qc_postgres_new
    environment:
      POSTGRES_USER: quantum_user
      POSTGRES_PASSWORD: quantum_secure_pass_123
      POSTGRES_DB: quantum_commerce
    ports:
      - "5432:5432"
    volumes:
      - postgres_data_new:/var/lib/postgresql/data

  redis:
    image: redis:7-alpine
    container_name: qc_redis_new
    command: redis-server --requirepass redis_secure_pass_456
    ports:
      - "6379:6379"
    volumes:
      - redis_data_new:/data

  vault:
    image: hashicorp/vault:1.15
    container_name: qc_vault_new
    cap_add:
      - IPC_LOCK
    environment:
      VAULT_DEV_ROOT_TOKEN_ID: dev_vault_token_789
      VAULT_DEV_LISTEN_ADDRESS: 0.0.0.0:8200
    ports:
      - "8200:8200"
    command: vault server -dev

volumes:
  postgres_data_new:
  redis_data_new:

/root/quantum-secure-commerce/docker-compose.monitoring-fixed.yml
version: '3.8'

services:
  prometheus:
    image: prom/prometheus:latest
    container_name: qsc_prometheus
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
      - '--web.console.libraries=/usr/share/prometheus/console_libraries'
      - '--web.console.templates=/usr/share/prometheus/consoles'
      - '--storage.tsdb.retention.time=7d'
      - '--web.enable-lifecycle'
    volumes:
      - ./monitoring/prometheus:/etc/prometheus
      - prometheus_data:/prometheus
    ports:
      - "9090:9090"
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "wget", "--quiet", "--tries=1", "--spider", "http://localhost:9090/-/healthy"]
      interval: 30s
      timeout: 10s
      retries: 3

  grafana:
    image: grafana/grafana:latest
    container_name: qsc_grafana
    environment:
      - GF_SECURITY_ADMIN_USER=admin
      - GF_SECURITY_ADMIN_PASSWORD=quantum_admin_123
      - GF_USERS_ALLOW_SIGN_UP=false
      - GF_INSTALL_PLUGINS=grafana-clock-panel,grafana-simple-json-datasource
    volumes:
      - grafana_data:/var/lib/grafana
      - ./monitoring/grafana:/etc/grafana/provisioning
    ports:
      - "3030:3000"
    depends_on:
      - prometheus
    restart: unless-stopped
    healthcheck:
      test: ["CMD-SHELL", "curl -f http://localhost:3000/api/health || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3

  # PostgreSQL metrics (chỉ khi postgres đang chạy)
  postgres-exporter:
    image: prometheuscommunity/postgres-exporter:latest
    container_name: qsc_postgres_exporter
    environment:
      DATA_SOURCE_NAME: "postgresql://quantum_user:quantum_secure_pass_123@host.docker.internal:5432/quantum_commerce?sslmode=disable"
    ports:
      - "9187:9187"
    restart: unless-stopped
    profiles: ["with-postgres"]

  # Redis metrics (chỉ khi redis đang chạy)  
  redis-exporter:
    image: oliver006/redis_exporter:latest
    container_name: qsc_redis_exporter
    environment:
      REDIS_ADDR: "redis://host.docker.internal:6379"
      REDIS_PASSWORD: "redis_secure_pass_456"
    ports:
      - "9121:9121"
    restart: unless-stopped
    profiles: ["with-redis"]

volumes:
  prometheus_data:
  grafana_data:

/root/quantum-secure-commerce/docker-compose.monitoring.yml
version: '3.8'

services:
  prometheus:
    image: prom/prometheus:latest
    container_name: qsc_prometheus
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
      - '--web.console.libraries=/usr/share/prometheus/console_libraries'
      - '--web.console.templates=/usr/share/prometheus/consoles'
      - '--storage.tsdb.retention.time=30d'
      - '--web.enable-lifecycle'
    volumes:
      - ./monitoring/prometheus:/etc/prometheus
      - prometheus_data:/prometheus
    ports:
      - "9090:9090"
    restart: unless-stopped

  grafana:
    image: grafana/grafana:latest
    container_name: qsc_grafana
    environment:
      - GF_SECURITY_ADMIN_USER=admin
      - GF_SECURITY_ADMIN_PASSWORD=quantum_secure_123
      - GF_USERS_ALLOW_SIGN_UP=false
    volumes:
      - grafana_data:/var/lib/grafana
      - ./monitoring/grafana:/etc/grafana/provisioning
    ports:
      - "3030:3000"
    restart: unless-stopped

  # PostgreSQL metrics
  postgres-exporter:
    image: wrouesnel/postgres_exporter:latest
    container_name: qsc_postgres_exporter
    environment:
      DATA_SOURCE_NAME: "postgresql://quantum_user:quantum_secure_pass_123@localhost:5432/quantum_commerce?sslmode=disable"
    ports:
      - "9187:9187"
    restart: unless-stopped

  # Redis metrics
  redis-exporter:
    image: oliver006/redis_exporter:latest
    container_name: qsc_redis_exporter
    environment:
      REDIS_ADDR: "redis://localhost:6379"
      REDIS_PASSWORD: "redis_secure_pass_456"
    ports:
      - "9121:9121"
    restart: unless-stopped

  # System metrics
  node-exporter:
    image: prom/node-exporter:latest
    container_name: qsc_node_exporter
    command:
      - '--path.rootfs=/host'
    volumes:
      - '/:/host:ro,rslave'
    ports:
      - "9100:9100"
    restart: unless-stopped

volumes:
  prometheus_data:
  grafana_data:

/root/quantum-secure-commerce/docker-compose.production.yml
# docker-compose.production.yml
version: '3.8'

services:
  # Load Balancer
  nginx:
    image: nginx:alpine
    container_name: qsc_nginx
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf
      - ./ssl:/etc/nginx/ssl
    depends_on:
      - api
    restart: unless-stopped

  # API Service (Multiple instances)
  api:
    build:
      context: .
      dockerfile: Dockerfile.prod
    deploy:
      replicas: 3
    environment:
      - APP_ENV=production
      - MASTER_PASSWORD=${MASTER_PASSWORD}
      - DB_PASSWORD=${DB_PASSWORD}
      - REDIS_PASSWORD=${REDIS_PASSWORD}
    volumes:
      - ./secrets:/app/secrets:ro
      - ./logs:/app/logs
    depends_on:
      - postgres
      - redis
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s
      timeout: 10s
      retries: 3

  # Database
  postgres:
    image: postgres:15
    container_name: qsc_postgres_prod
    environment:
      POSTGRES_DB: ${DB_NAME}
      POSTGRES_USER: ${DB_USER}
      POSTGRES_PASSWORD: ${DB_PASSWORD}
      POSTGRES_INITDB_ARGS: "--auth-local=trust --auth-host=md5"
    volumes:
      - postgres_data_prod:/var/lib/postgresql/data
      - ./database/init:/docker-entrypoint-initdb.d
    ports:
      - "5432:5432"
    restart: unless-stopped
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${DB_USER}"]
      interval: 10s
      timeout: 5s
      retries: 5

  # Redis Cluster
  redis:
    image: redis:7-alpine
    container_name: qsc_redis_prod
    command: redis-server --requirepass ${REDIS_PASSWORD} --maxmemory 512mb --maxmemory-policy allkeys-lru
    volumes:
      - redis_data_prod:/data
    ports:
      - "6379:6379"
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "redis-cli", "--no-auth-warning", "-a", "${REDIS_PASSWORD}", "ping"]
      interval: 10s
      timeout: 5s
      retries: 3

  # Vault for Secret Management
  vault:
    image: hashicorp/vault:1.15
    container_name: qsc_vault_prod
    cap_add:
      - IPC_LOCK
    environment:
      VAULT_ADDR: http://0.0.0.0:8200
      VAULT_API_ADDR: http://0.0.0.0:8200
    volumes:
      - vault_data_prod:/vault/data
      - ./vault/config:/vault/config
    ports:
      - "8200:8200"
    command: vault server -config=/vault/config/vault.hcl
    restart: unless-stopped

  # Monitoring Stack
  prometheus:
    image: prom/prometheus:latest
    container_name: qsc_prometheus_prod
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
      - '--storage.tsdb.retention.time=90d'
      - '--web.enable-lifecycle'
    volumes:
      - ./monitoring/prometheus:/etc/prometheus
      - prometheus_data_prod:/prometheus
    ports:
      - "9090:9090"
    restart: unless-stopped

  grafana:
    image: grafana/grafana:latest
    container_name: qsc_grafana_prod
    environment:
      - GF_SECURITY_ADMIN_USER=${GRAFANA_USER}
      - GF_SECURITY_ADMIN_PASSWORD=${GRAFANA_PASSWORD}
      - GF_USERS_ALLOW_SIGN_UP=false
      - GF_SERVER_ROOT_URL=https://monitoring.quantum-commerce.com
    volumes:
      - grafana_data_prod:/var/lib/grafana
      - ./monitoring/grafana:/etc/grafana/provisioning
    ports:
      - "3000:3000"
    restart: unless-stopped

  # Log Management
  loki:
    image: grafana/loki:latest
    container_name: qsc_loki_prod
    command: -config.file=/etc/loki/local-config.yaml
    volumes:
      - loki_data_prod:/loki
    ports:
      - "3100:3100"
    restart: unless-stopped

  promtail:
    image: grafana/promtail:latest
    container_name: qsc_promtail_prod
    volumes:
      - ./logs:/var/log/app
      - ./monitoring/promtail:/etc/promtail
    command: -config.file=/etc/promtail/config.yml
    restart: unless-stopped

volumes:
  postgres_data_prod:
  redis_data_prod:
  vault_data_prod:
  prometheus_data_prod:
  grafana_data_prod:
  loki_data_prod:

networks:
  default:
    name: quantum_secure_network
    driver: bridge
/root/quantum-secure-commerce/docker-compose.yml
version: '3.8'

services:
  # Database
  postgres:
    image: postgres:15-alpine
    container_name: qc_postgres
    environment:
      POSTGRES_DB: quantum_commerce
      POSTGRES_USER: quantum_user
      POSTGRES_PASSWORD: quantum_pass
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U quantum_user -d quantum_commerce"]
      interval: 30s
      timeout: 10s
      retries: 3

  # Redis Cache
  redis:
    image: redis:7-alpine
    container_name: qc_redis
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 30s
      timeout: 10s
      retries: 3

  # Vault (for advanced secret management)
  vault:
    image: hashicorp/vault:1.15
    container_name: qc_vault
    ports:
      - "8200:8200"
    environment:
      VAULT_DEV_ROOT_TOKEN_ID: quantum_dev_token
      VAULT_DEV_LISTEN_ADDRESS: 0.0.0.0:8200

  # Main API
  api:
    build: .
    container_name: qc_api
    ports:
      - "8000:8000"
    environment:
      - APP_ENV=development
      - USE_REAL_CRYPTO=true
      - DATABASE_URL=postgresql://quantum_user:quantum_pass@qc_postgres:5432/quantum_commerce
      - REDIS_URL=redis://qc_redis:6379/0
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    volumes:
      - ./secrets:/app/secrets:ro

  # Prometheus
  prometheus:
    image: prom/prometheus:latest
    container_name: qc_prometheus
    ports:
      - "9090:9090"
    volumes:
      - ./monitoring/prometheus.yml:/etc/prometheus/prometheus.yml:ro
      - prometheus_data:/prometheus
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
      - '--web.console.libraries=/etc/prometheus/console_libraries'
      - '--web.console.templates=/etc/prometheus/consoles'
      - '--storage.tsdb.retention.time=200h'
      - '--web.enable-lifecycle'
    depends_on:
      - api

  # Grafana
  grafana:
    image: grafana/grafana:latest
    container_name: qc_grafana
    ports:
      - "3030:3000"
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=quantum_admin_123
      - GF_USERS_ALLOW_SIGN_UP=false
    volumes:
      - grafana_data:/var/lib/grafana
    depends_on:
      - prometheus

volumes:
  postgres_data:
  redis_data:
  prometheus_data:
  grafana_data:
/root/quantum-secure-commerce/main.py
import sys
import os
import uuid
import logging
import uvicorn
from pathlib import Path
from fastapi import FastAPI, Depends, HTTPException, Request, status
from fastapi.middleware.cors import CORSMiddleware
from fastapi.middleware.trustedhost import TrustedHostMiddleware
from fastapi.responses import JSONResponse
from sqlalchemy.orm import Session
from contextlib import asynccontextmanager
from typing import Optional, List, Dict, Any
from decimal import Decimal
from datetime import datetime

# Add project root to Python path
project_root = Path(__file__).parent
sys.path.insert(0, str(project_root))

# Import configurations FIRST
from config.dev_config import config, SecurityConfig
# Validate secrets trước khi khởi động
try:
    SecurityConfig.validate()
    print("✅ Security configuration validated")
except Exception as e:
    print(f"❌ Security configuration error: {e}")
    print("⚠️ Continuing with default secrets...")

# Import database with error handling
try:
    from database.schema import Base, User, AuditLog, Transaction
    from database import engine, get_db
    print("✅ Database imports successful")
except Exception as e:
    print(f"⚠️ Database import error: {e}")
    # Create minimal fallback
    engine = None
    def get_db():
        yield None
    
    class Base:
        metadata = type('MockMetadata', (), {'create_all': lambda **kwargs: None})()
    class User:
        id = None
        email = None
    class AuditLog:
        pass
    class Transaction:
        pass

# Import services with error handling
try:
    from services.auth_service import auth_service
    print("✅ Auth service imported")
except Exception as e:
    print(f"⚠️ Auth service import error: {e}")
    # Create mock auth service
    class MockAuthService:
        def verify_token(self, token):
            return {"user_id": "demo", "email": "demo@test.com"}
        def validate_password_strength(self, password):
            return len(password) >= 8
        def hash_password(self, password):
            return f"hashed_{password}"
        def verify_password(self, password, hash):
            return True
        def create_access_token(self, data):
            import jwt
            return jwt.encode(data, "dev_secret", algorithm="HS256")
    
    auth_service = MockAuthService()

# Import crypto with fallback
USE_REAL_CRYPTO = os.getenv('USE_REAL_CRYPTO', 'false').lower() == 'true'

try:
    if USE_REAL_CRYPTO:
        from crypto.real_dilithium import RealDilithiumSigner as DilithiumSigner
        print("✅ Using REAL cryptographic implementations")
    else:
        from crypto.dilithium_signer import DilithiumSigner
        print("⚠️ Using mock crypto (development mode)")
        
    from crypto.ibe_system import IBESystem
    
except Exception as e:
    print(f"⚠️ Crypto import error: {e}")
    # Create mock crypto classes
    class DilithiumSigner:
        def __init__(self):
            pass
        def sign_transaction(self, data, **kwargs):
            return {"signature": "mock_signature", "data": data}
        def verify_signature(self, signed_data, **kwargs):
            return True
            
    class IBESystem:
        def __init__(self):
            pass
        def encrypt_for_user(self, data, user_id):
            return f"encrypted_{data}"

# Setup logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# JWT Bearer authentication
def jwt_bearer(request: Request):
    """Real JWT bearer authentication"""
    auth_header = request.headers.get("Authorization")
    if not auth_header:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Authorization header missing"
        )
    
    try:
        user_data = auth_service.verify_token(auth_header)
        return user_data
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Auth error: {e}")
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Authentication failed"
        )

# Middleware functions
async def security_middleware(request: Request, call_next):
    """Basic security middleware"""
    response = await call_next(request)
    response.headers["X-Content-Type-Options"] = "nosniff"
    response.headers["X-Frame-Options"] = "DENY"
    response.headers["X-XSS-Protection"] = "1; mode=block"
    return response

async def rate_limit_middleware(request: Request, call_next):
    """Basic rate limiting middleware"""
    response = await call_next(request)
    return response

@asynccontextmanager
async def lifespan(app: FastAPI):
    """Application lifespan management"""
    logger.info("🚀 Starting Quantum Commerce API...")
    
    # Initialize crypto systems
    try:
        logger.info("🔐 Initializing crypto systems...")
    except Exception as e:
        logger.warning(f"Crypto initialization warning: {e}")
    
    # Create database tables
    try:
        if engine:
            Base.metadata.create_all(bind=engine)
            logger.info("✅ Database tables created")
    except Exception as e:
        logger.warning(f"Database table creation warning: {e}")
    
    yield
    
    # Shutdown
    logger.info("👋 Shutting down Quantum Commerce API...")

# Create FastAPI app
app = FastAPI(
    title="Quantum Commerce API",
    description="Secure e-commerce platform with post-quantum cryptography",
    version="1.0.0",
    lifespan=lifespan
)

# Add middleware
app.add_middleware(TrustedHostMiddleware, allowed_hosts=["*"])
app.middleware("http")(security_middleware)
app.middleware("http")(rate_limit_middleware)

# CORS configuration
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Pydantic models
from pydantic import BaseModel, EmailStr, Field

class RegisterRequest(BaseModel):
    email: EmailStr
    username: str = Field(..., min_length=3, max_length=50)
    password: str = Field(..., min_length=8)
    full_name: Optional[str] = None

class LoginRequest(BaseModel):
    email: EmailStr
    password: str

class PaymentRequest(BaseModel):
    amount: Decimal = Field(..., gt=0)
    currency: str = Field(default="USD", pattern="^[A-Z]{3}$")
    payment_method: str
    payment_data: dict
    items: List[dict]

# API Routes

# Health Check
@app.get("/")
async def health_check():
    """Health check endpoint"""
    return {
        "status": "healthy",
        "service": "Quantum Commerce API",
        "version": "1.0.0",
        "timestamp": datetime.utcnow().isoformat(),
        "crypto_mode": "real" if USE_REAL_CRYPTO else "mock"
    }

users_storage = {}

@app.post("/api/auth/register")
async def register(
    request: RegisterRequest,
    req: Request,
    db: Session = Depends(get_db)
):
    """User registration with real storage"""
    logger.info(f"Registration attempt: {request.email}")
    
    # Check if user already exists
    if request.email in users_storage:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Email already registered"
        )
    
    # Validate password strength
    if not auth_service.validate_password_strength(request.password):
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Password must be at least 8 characters with uppercase, lowercase, digit and special character"
        )
    
    # Hash password
    password_hash = auth_service.hash_password(request.password)
    
    # Create user data
    user_data = {
        "id": str(uuid.uuid4()),
        "email": request.email,
        "username": request.username,
        "full_name": request.full_name,
        "password_hash": password_hash,  # ← LUU PASSWORD HASH
        "is_admin": False,
        "created_at": datetime.utcnow().isoformat()
    }
    
    # Store user in memory
    users_storage[request.email] = user_data
    
    # Create access token (không gồm password)
    token_data = {
        "user_id": user_data["id"],
        "sub": user_data["email"],
        "email": user_data["email"],
        "username": user_data["username"],
        "is_admin": user_data["is_admin"]
    }
    access_token = auth_service.create_access_token(token_data)
    
    logger.info(f"✅ User registered: {request.email}")
    
    return {
        "message": "Registration successful",
        "access_token": access_token,
        "token_type": "bearer",
        "user": token_data  # Không trả password
    }

@app.post("/api/auth/login") 
async def login(
    request: LoginRequest,
    req: Request,
    db: Session = Depends(get_db)
):
    """User login with REAL credential validation"""
    logger.info(f"Login attempt: {request.email}")
    
    # Check if user exists
    if request.email not in users_storage:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid credentials"
        )
    
    user = users_storage[request.email]
    
    # Verify password
    if not auth_service.verify_password(request.password, user["password_hash"]):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid credentials"
        )
    
    # Create token data
    token_data = {
        "user_id": user["id"],
        "sub": user["email"],
        "email": user["email"],
        "username": user["username"],
        "is_admin": user["is_admin"]
    }
    
    access_token = auth_service.create_access_token(token_data)
    
    logger.info(f"✅ Login successful: {request.email}")
    
    return {
        "access_token": access_token,
        "token_type": "bearer",
        "user": token_data
    }

# Debug endpoint để xem users đã register
@app.get("/api/debug/users")
async def debug_users():
    """Debug: xem users đã register (DEVELOPMENT ONLY)"""
    return {
        "total_users": len(users_storage),
        "users": [
            {
                "email": email,
                "username": user["username"],
                "created_at": user["created_at"]
            }
            for email, user in users_storage.items()
        ]
    }

@app.post("/api/auth/logout")
async def logout(
    req: Request,
    current_user: dict = Depends(jwt_bearer),
    db: Session = Depends(get_db)
):
    """User logout"""
    logger.info(f"Logout: {current_user.get('email')}")
    return {"message": "Logged out successfully"}

@app.post("/api/auth/refresh")
async def refresh_token(
    request: dict,
    req: Request
):
    """Refresh JWT token"""
    return {"access_token": "refreshed_token_123", "token_type": "bearer"}



# In-memory storage for orders (thay thế database)
orders_storage = {}

# Modify payment processing to store order details
@app.post("/api/payments/process")
async def process_payment(
    payment_request: PaymentRequest,
    current_user: dict = Depends(jwt_bearer),
    db: Session = Depends(get_db)
):
    try:
        user_email = current_user.get("sub")
        transaction_id = str(uuid.uuid4())
        
        logger.info(f"Processing payment: {payment_request.amount} {payment_request.currency} for user {user_email}")
        
        # Store complete order details
        order_details = {
            "transaction_id": transaction_id,
            "customer_email": user_email,
            "customer_id": current_user.get("user_id"),
            "amount": float(payment_request.amount),
            "currency": payment_request.currency,
            "status": "completed",
            "timestamp": datetime.utcnow().isoformat(),
            "payment_method": payment_request.payment_method,
            "items": payment_request.items,
            "payment_data": payment_request.payment_data,
            "quantum_security": {
                "ibe_encrypted": True,
                "dilithium_signed": True,
                "signature_verified": False
            }
        }
        
        # Store in memory
        orders_storage[transaction_id] = order_details
        
        logger.info(f"✅ Payment processed successfully: {transaction_id}")
        
        return {
            "status": "completed",
            "transaction_id": transaction_id,
            "amount": payment_request.amount,
            "currency": payment_request.currency,
            "timestamp": order_details["timestamp"]
        }
    except Exception as e:
        logger.error(f"Payment processing error: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

# Real order details endpoint
@app.get("/api/orders/{transaction_id}")
async def get_order_details(
    transaction_id: str,
    current_user: dict = Depends(jwt_bearer)
):
    """Get detailed order information"""
    if transaction_id not in orders_storage:
        raise HTTPException(status_code=404, detail="Order not found")
    
    order = orders_storage[transaction_id]
    
    # Verify ownership
    if order["customer_id"] != current_user.get("user_id"):
        raise HTTPException(status_code=403, detail="Access denied")
    
    return order

# Real transactions list from storage
@app.get("/api/transactions")
async def get_transactions(current_user: dict = Depends(jwt_bearer)):
    """Get user transaction history from storage"""
    user_id = current_user.get("user_id")
    
    # Filter orders by user
    user_transactions = [
        {
            "transaction_id": order["transaction_id"],
            "amount": order["amount"],
            "currency": order["currency"],
            "status": order["status"],
            "timestamp": order["timestamp"]
        }
        for order in orders_storage.values()
        if order["customer_id"] == user_id
    ]
    
    return {"transactions": user_transactions}

@app.get("/api/crypto/status")
async def crypto_status():
    """Get crypto system status"""
    return {
        "status": "active",
        "dilithium": {"status": "active", "algorithm": "Dilithium3"},
        "ibe": {"status": "active", "algorithm": "enhanced_ibe"},
        "quantum_secure": True
    }

@app.get("/api/payments/{payment_id}")
async def get_payment_details(payment_id: str, current_user: dict = Depends(jwt_bearer)):
    return {
        "payment_id": payment_id,
        "status": "completed",
        "customer_id": current_user.get("user_id"),
        "timestamp": datetime.utcnow().isoformat()
    }

@app.post("/api/payments/verify")
async def verify_payment(
    request: dict,
    current_user: dict = Depends(jwt_bearer)
):
    """Verify payment signature"""
    try:
        transaction_id = request.get("transaction_id") or request.get("payment_id")
        
        if not transaction_id:
            raise HTTPException(status_code=400, detail="Transaction ID required")
            
        return {
            "transaction_id": transaction_id,
            "verified": True,
            "quantum_secure": True,
            "message": "Payment signature verified successfully",
            "algorithm": "Dilithium3",
            "timestamp": datetime.utcnow().isoformat()
        }
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))

@app.get("/api/orders/{order_id}")
async def get_order_details(
    order_id: str,
    current_user: dict = Depends(jwt_bearer)
):
    """Get detailed order information"""
    return {
        "order_id": order_id,
        "customer_id": current_user.get("user_id"),
        "status": "completed",
        "amount": 215.99,
        "currency": "USD",
        "date": datetime.utcnow().isoformat(),
        "items": [
            {"name": "Quantum Device", "price": 199.99, "quantity": 1}
        ],
        "payment_method": "credit_card",
        "quantum_secured": True
    }

@app.post("/api/payments/verify")
async def verify_payment(
    request: dict,
    current_user: dict = Depends(jwt_bearer)
):
    """Verify payment signature"""
    try:
        # Debug log
        logger.info(f"Verify request: {request}")
        
        transaction_id = request.get("transaction_id")
        
        if not transaction_id:
            logger.error("No transaction_id provided")
            raise HTTPException(status_code=400, detail="transaction_id is required")
            
        logger.info(f"Verifying transaction: {transaction_id}")
        
        return {
            "transaction_id": transaction_id,
            "verified": True,  # ← Match với frontend
            "quantum_secure": True,
            "message": "Payment signature verified successfully",
            "algorithm": "Dilithium3",
            "timestamp": datetime.utcnow().isoformat()
        }
        
    except Exception as e:
        logger.error(f"Verification error: {str(e)}")
        raise HTTPException(status_code=400, detail=f"Verification failed: {str(e)}")

@app.get("/api/users/me")
async def get_current_user(
    current_user: dict = Depends(jwt_bearer),
    db: Session = Depends(get_db)
):
    """Get current user information"""
    return current_user

@app.get("/api/crypto/ibe/public-params")
async def get_ibe_params():
    """Get IBE public parameters"""
    return {
        "public_params": "mock_ibe_params",
        "algorithm": "IBE",
        "curve": "BN254"
    }

@app.get("/api/crypto/keys/merchant-public")
async def get_merchant_keys():
    """Get merchant public keys"""
    return {
        "dilithium_public_key": "mock_dilithium_public_key",
        "key_id": "merchant_001"
    }

@app.get("/metrics")
async def get_metrics():
    """Prometheus metrics endpoint"""
    return {
        "transactions_total": 1234,
        "payments_processed": 5678,
        "crypto_operations": 9999
    }

@app.get("/api/admin/stats")
async def get_admin_stats(
    current_user: dict = Depends(jwt_bearer),
    db: Session = Depends(get_db)
):
    """Get admin statistics"""
    if not current_user.get("is_admin"):
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Admin access required"
        )
    
    return {
        "total_users": 100,
        "total_transactions": 1000,
        "total_revenue": 50000.00
    }

# Error Handlers
@app.exception_handler(HTTPException)
async def http_exception_handler(request: Request, exc: HTTPException):
    return JSONResponse(
        status_code=exc.status_code,
        content={"detail": exc.detail, "type": "http_exception"}
    )

@app.exception_handler(Exception)
async def general_exception_handler(request: Request, exc: Exception):
    logger.error(f"Unhandled exception: {exc}")
    return JSONResponse(
        status_code=500,
        content={"detail": "Internal server error", "type": "server_error"}
    )

if __name__ == "__main__":
    print("🚀 Starting Quantum Commerce API...")
    uvicorn.run(
        "main:app",
        host="0.0.0.0",
        port=8000,
        reload=True,
        log_level="info"
    )
/root/quantum-secure-commerce/requirements_crypto.txt
# requirements_crypto.txt
# Add these to your requirements.txt

# Post-Quantum Cryptography
pqcrypto==0.1.0  # For Dilithium
#liboqs-python==0.7.2  # Alternative for quantum-safe algorithms

# Traditional Cryptography  
cryptography==41.0.7
pycryptodome==3.19.0
PyNaCl==1.5.0

# For IBE (Identity-Based Encryption)
#charm-crypto  # May need manual installation
#pypbc # Pairing-based crypto

# Key Management
python-jose[cryptography]==3.3.0
jwcrypto==1.5.0
/root/quantum-secure-commerce/requirements_missing.txt
# Missing dependencies
PyJWT==2.8.0
python-jose[cryptography]==3.3.0
email-validator==2.0.0
python-multipart==0.0.6

# Also ensure these are installed
cryptography==41.0.4
passlib[bcrypt]==1.7.4
/root/quantum-secure-commerce/requirements.txt
# Core Framework
flask==2.3.3
fastapi==0.103.1
uvicorn==0.23.2
pydantic==2.4.2

# Cryptography Libraries
cryptography==41.0.4
pycryptodome==3.19.0
pyopenssl==23.2.0

# Post-Quantum Cryptography
# Note: liboqs-python cần được cài đặt riêng
# pip install git+https://github.com/open-quantum-safe/liboqs-python.git

# Identity-Based Encryption
# Note: Charm-Crypto cần được build từ source
# Xem hướng dẫn tại: https://jhuisi.github.io/charm/install_source.html

# Database
sqlalchemy==2.0.21
psycopg2-binary==2.9.7
alembic==1.12.0
redis==5.0.0

# Security & Authentication
python-jose[cryptography]==3.3.0
passlib[bcrypt]==1.7.4
python-multipart==0.0.6
email-validator==2.0.0

# Utilities
python-dotenv==1.0.0
pyyaml==6.0.1
click==8.1.7
colorlog==6.7.0

# API & Web
requests==2.31.0
httpx==0.25.0
python-dateutil==2.8.2
pytz==2023.3

# Monitoring & Logging
prometheus-client==0.17.1
python-json-logger==2.0.7

# Testing
pytest==7.4.2
pytest-asyncio==0.21.1
pytest-cov==4.1.0
faker==19.6.2

# Development
black==23.9.1
flake8==6.1.0
mypy==1.5.1
pre-commit==3.4.0
/root/quantum-secure-commerce/list.txt
Package            Version
------------------ ---------
alembic            1.12.0
annotated-types    0.7.0
anyio              3.7.1
attrs              25.3.0
bcrypt             4.3.0
black              23.9.1
blinker            1.9.0
certifi            2025.4.26
cffi               1.17.1
cfgv               3.4.0
Charm-Crypto       0.50
charset-normalizer 3.4.2
click              8.1.7
coincurve          21.0.0
colorama           0.4.6
colorlog           6.7.0
coverage           7.8.2
cryptography       41.0.7
Deprecated         1.2.18
distlib            0.3.9
dnspython          2.7.0
ecdsa              0.19.1
eciespy            0.4.4
email-validator    2.0.0
Faker              19.6.2
fastapi            0.103.1
fernet             1.0.1
filelock           3.18.0
flake8             6.1.0
Flask              2.3.3
greenlet           3.2.2
h11                0.14.0
httpcore           0.18.0
httpx              0.25.0
hvac               2.3.0
hypothesis         6.135.1
identify           2.6.12
idna               3.10
iniconfig          2.1.0
itsdangerous       2.2.0
Jinja2             3.1.6
jwcrypto           1.5.0
liboqs-python      0.12.0
Mako               1.3.10
MarkupSafe         3.0.2
mccabe             0.7.0
mypy               1.5.1
mypy_extensions    1.1.0
nodeenv            1.9.1
packaging          25.0
passlib            1.7.4
pathspec           0.12.1
pip                25.1.1
platformdirs       4.3.8
pluggy             1.6.0
pqcrypto           0.3.1
pre-commit         3.4.0
prometheus-client  0.17.1
psycopg2-binary    2.9.7
pyaes              1.6.1
pyasn1             0.6.1
pycodestyle        2.11.1
pycparser          2.22
pycryptodome       3.19.0
pydantic           2.4.2
pydantic_core      2.10.1
pyflakes           3.1.0
PyJWT              2.8.0
PyNaCl             1.5.0
pyOpenSSL          23.2.0
pyparsing          2.4.0
pytest             7.4.2
pytest-asyncio     0.21.1
pytest-cov         4.1.0
python-dateutil    2.8.2
python-dotenv      1.0.0
python-jose        3.3.0
python-json-logger 2.0.7
python-multipart   0.0.6
pytz               2023.3
PyYAML             6.0.1
redis              5.0.0
requests           2.31.0
rsa                4.9.1
setuptools         80.9.0
six                1.17.0
sniffio            1.3.1
sortedcontainers   2.4.0
SQLAlchemy         2.0.21
starlette          0.27.0
typing_extensions  4.13.2
urllib3            2.4.0
uvicorn            0.23.2
virtualenv         20.31.2
Werkzeug           3.1.3
wheel              0.45.1
wrapt              1.17.2

/root/quantum-secure-commerce/Dockerfile
FROM python:3.12-slim

# Install system dependencies
RUN apt-get update && apt-get install -y \
    gcc \
    python3-dev \
    libpq-dev \
    && rm -rf /var/lib/apt/lists/*

# Set working directory
WORKDIR /app

# Copy requirements
COPY requirements.txt .

# Install Python dependencies
RUN pip install --no-cache-dir -r requirements.txt

# Install additional packages
RUN pip install --no-cache-dir \
    PyJWT==2.8.0 \
    python-jose[cryptography]==3.3.0 \
    email-validator==2.0.0 \
    python-multipart==0.0.6 \
    psycopg2-binary==2.9.7

# Copy application
COPY . .

# Create directories
RUN mkdir -p keys/ibe keys/dilithium logs secrets

# Expose port
EXPOSE 8000

# Run command
CMD ["python", "main.py"]
